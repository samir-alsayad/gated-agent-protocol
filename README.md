# Gated Agent Protocol (GAP)

**Agents propose. Supervisors approve. The Ledger remembers.**

[![License](https://img.shields.io/badge/License-MIT-green)](LICENSE)
[![Python](https://img.shields.io/badge/Python-3.10+-blue)](https://python.org)
[![Status](https://img.shields.io/badge/Status-v1.0.0-brightgreen)]()

GAP is a **Protocol Engine** that enforces **Structure**, **Security**, and **Traceability** in agentic workflows. It prevents agents from deviating from requirements by strictly enforcing a Workflow Compliance Layer.

> GAP is not a chat interface. It's not a wrapper around an AI model.
> It's **infrastructure for agents** ‚Äî the same way CI/CD is infrastructure for code.

---

## How It Works

A GAP project starts with a **manifest** ‚Äî a declarative definition of the entire workflow:

```yaml
# manifest.yaml
kind: project
name: my-project
extends:
  - protocol: software-engineering

flow:
  - step: requirements
    artifact: docs/requirements.md
    gate: true                      # Supervisor must approve

  - step: design
    artifact: docs/design.md
    gate: true
    needs: [requirements]

  - step: tasks
    artifact: .gap/tasks.yaml       # Machine-readable YAML
    view: docs/tasks.md             # Human-readable markdown
    gate: true
    needs: [design]

  - step: plan
    artifact: .gap/plan.yaml        # Execution envelopes
    gate: true
    needs: [tasks]

  - step: implementation
    artifact: src/
    gate: false                     # Autonomous execution
    needs: [plan]
```

The manifest defines **what** the agent must produce and **where** the supervisor intervenes. GAP then enforces this in two phases:

### 1. Alignment Phase ‚Äî *What should we build, and how are we allowed to execute it?*

GAP strictly separates **Necessity** from **Permission**. 

*   **Tasks** answer: *"What must change to satisfy the design?"* (Agent proposes)
*   **Plan** answers: *"What powers and resources am I willing to grant to achieve this?"* (Supervisor defines)

The workflow follows a distinct lifecycle to ensure these are never conflated:

```
Requirements ‚Üí Design ‚Üí Tasks (proposed)
                         ‚Üì
                 Supervisor accepts Tasks
                         ‚Üì
                 Plan is authored manually 
                         ‚Üì
                 GAP gates execution
                         ‚Üì
                 Checkpoints enforce review
```

Once the agent proposes the Tasks, the supervisor constructs the **Plan**. The Plan attaches an *authorized execution envelope* to each task. This envelope contains:
*   **ACL**: What files the task may touch.
*   **Execution**: Local vs Cloud compute venue.
*   **Model**: Which specific cognitive model is authorized.
*   **Checkpoints**: Where human interruption is required.

GAP does not enforce security, sandbox code, or auto-route models. It is strictly a **consent ledger** that records these proposals and requires human approval for all state transitions.

### 2. Execution Phase ‚Äî *Build it.*
Once the Plan is locked, the agent coordinates execution. When it hits an approved checkpoint boundary, GAP blocks further action until the supervisor intervenes.

---

## Why GAP Exists

| Problem | How GAP Solves It |
|---|---|
| Agents drift from requirements over long contexts | **Gated checkpoints** re-anchor intent at every phase |
| No way to know *what the agent decided* vs *what you approved* | **Immutable Ledger** tracks every state transition |
| Agents "hallucinate" their own security policies | **Deterministic ACLs** ‚Äî security is code, not prompts |
| No traceability from code back to intent | **Chain of Custody** links every task to a requirement |

### The Core Principle: Determinism vs. Probabilism

|  | **Deterministic (Protocol)** | **Probabilistic (Agent)** |
|---|---|---|
| **Who** | GAP | The LLM |
| **What** | Gates, ACLs, checkpoints, policy | Requirements, design, code |
| **Trust model** | Absolute ‚Äî defined in code | Gated ‚Äî proposed, then approved |

Authority is never generated by an LLM. It is enforced by the protocol.

---

## What's Built Today

### Core Engine
- **`gap check status`** ‚Äî View current state of all phases and gates
- **`gap scribe create`** ‚Äî Generate artifacts for any phase
- **`gap gate list / approve`** ‚Äî Manage gate approvals with ACL extraction
- **`gap check traceability`** ‚Äî Verify chain of custody from requirements ‚Üí tasks
- **`gap checkpoint verify/approve`** ‚Äî Runtime checkpoint enforcement
- **Manifest System** ‚Äî YAML workflow definition with protocol inheritance
- **Ledger System** ‚Äî Immutable record of approvals and state transitions
- **Basic ACL** ‚Äî Access control list parsing and storage

### Current Development Focus
- **Task/Plan Separation** ‚Äî Distinguishing necessity (Tasks) from permission (Plan)
- **Execution Envelopes** ‚Äî ACL, locality, model assignment, checkpoints in Plan
- **Enhanced Gate System** ‚Äî Plan construction during task approval
- **Structured Task Model** ‚Äî YAML tasks with traceability and references

---

## üó∫Ô∏è Roadmap

### Plan Layer Implementation *(Current Focus)*
> [.kiro/specs/gap-core-system/](.kiro/specs/gap-core-system/)

The current focus: **Complete separation of Tasks from Plan** with explicit execution envelopes.

- **Task Model** ‚Äî Structured YAML tasks with traceability to design/requirements
- **Plan Construction** ‚Äî Supervisor-defined execution envelopes per task
- **Execution Envelopes** ‚Äî ACL, locality, model assignment, checkpoints in unified Plan file
- **Manual Authority Phase** ‚Äî Supervisor defines all execution parameters, no AI suggestions

```yaml
# Coming: Plan envelope in .gap/plan.yaml
plan:
  T-1:
    acl:
      filesystem:
        write: [src/auth.py, tests/test_auth.py]
        read: [src/utils.py]
      shell: [pytest, python -m build]
    cognition:
      execution: local
      model: qwen3-coder-next
    checkpoints:
      - after_implementation
      - before_merge
```

### Core Engine Enhancements
- **Enhanced Gate System** ‚Äî `gap gate approve --edit-envelope` for Plan construction
- **Plan Management CLI** ‚Äî `gap plan show/edit/validate` commands
- **Checkpoint Enforcement** ‚Äî Runtime pause at declared boundaries
- **Ledger Enhancement** ‚Äî Record Plan approvals with execution parameters

### Future Considerations
- **Model Control Layer** ‚Äî Explicit model assignment without orchestration
- **Session Model** ‚Äî Law & Exception governance patterns
- **Protocol Templates** ‚Äî Domain-specific workflow patterns

---

## üå± Example Project: Ascent

**[Ascent](https://github.com/samir-alsayad/ascent)** is a real-world project built with GAP governance. It's a capability resolver for learning ‚Äî given a goal and a learner's verified state, it computes the minimal transformation required and delivers only the learning needed to close that gap.

Ascent is **not** a chat interface. It's a structured system with its own engine, knowledge graphs, and evidence models ‚Äî exactly the kind of project where uncontrolled agent behavior would cause structural failures. GAP provides the guardrails.

> Ascent demonstrates how GAP works in practice: requirements define learning goals, design maps the capability graph, tasks decompose into module generation, and execution is checkpointed to prevent drift.

---

## Quick Start

### Install

```bash
pip install git+https://github.com/samir-alsayad/gated-agent-protocol.git@v1.0.0
```

### Verify

```bash
gap --help
```

### Basic Workflow

```bash
# Check current state
gap check status manifest.yaml

# Create a proposal for requirements
gap scribe create requirements --manifest manifest.yaml

# Review and approve
gap gate list --manifest manifest.yaml
gap gate approve requirements --manifest manifest.yaml
```

**Output:**
```
üü¢ requirements: UNLOCKED
üîí design: LOCKED (waiting for: requirements)
üîí implementation: LOCKED (waiting for: design)
```

---

## Documentation

| Document | Description |
|----------|-------------|
| [Whitepaper](docs/WHITE_PAPER.md) | The full theory and architecture |
| [Protocol Schema](docs/SCHEMA_PROTOCOL.md) | How to define protocols |
| [Project Schema](docs/SCHEMA_PROJECT.md) | How to configure projects |
| [CLI Reference](docs/cli.md) | All commands |
| [Integration Guide](docs/integration_guide.md) | Adding GAP to your tools |
| [Model Control Layer](docs/Model%20Control%20Layer/) | Upcoming MCL requirements and design |

---

## Requirements

- Python 3.10+
- macOS, Linux, or Windows
- No external services required (YAML/File-based Ledger)

## Development

```bash
git clone https://github.com/samir-alsayad/gated-agent-protocol.git
cd gated-agent-protocol
python -m venv .venv
source .venv/bin/activate
pip install -e .
pytest tests/ -v
```

---

## ü§ù Contributing

We welcome contributions! See [CONTRIBUTING.md](CONTRIBUTING.md).

## üîí Security

See [SECURITY.md](SECURITY.md) for reporting vulnerabilities.

---

*Open Standard ‚Äî v1.0.0 ‚Äî 2026*
*Created by Samir Alsayad.*
